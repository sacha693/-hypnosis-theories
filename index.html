
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>互動式催眠理論瀏覽器</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700&display=swap" rel="stylesheet">
    <!-- Chosen Palette: Warm Neutrals (Slate, Zinc, Amber) -->
    <!-- Application Structure Plan: A dashboard-style SPA with a left-side navigation panel for theory selection and a main content area for dynamic display. This non-linear structure promotes user-driven exploration and comparison, which is more effective for dense academic content than a simple scrollable page. Key interactions include single-view exploration, a dedicated two-theory side-by-side comparison mode, and an interactive radar chart for visual synthesis. -->
    <!-- Visualization & Content Choices: Report Info: 10 distinct hypnosis theories. Goal: Compare and synthesize qualitative concepts. Viz/Method: A Radar Chart (Chart.js/Canvas) to visually profile theories across 5 synthesized dimensions (e.g., Internal Experience, Social Interaction). Interaction: Chart updates on theory selection, overlaying data in comparison mode. Justification: This transforms textual data into a powerful visual comparison tool, aiding synthesis. Other content is presented in interactive HTML cards. -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
    <style>
        body {
            font-family: 'Noto Sans TC', sans-serif;
            background-color: #f1f5f9; /* slate-100 */
        }
        .chart-container {
            position: relative;
            width: 100%;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
            height: 300px;
            max-height: 400px;
        }
        @media (min-width: 768px) {
            .chart-container {
                height: 400px;
            }
        }
        .nav-item.active {
            background-color: #d97706; /* amber-600 */
            color: white;
        }
        .nav-item.compare-active {
            background-color: #18181b; /* zinc-900 */
            color: white;
        }
        .content-card {
            transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
        }
        .content-card.loading {
            opacity: 0;
            transform: translateY(10px);
        }
    </style>
</head>
<body class="text-slate-800">

    <div class="container mx-auto p-4 md:p-8 max-w-7xl">
        <header class="text-center mb-8">
            <h1 class="text-4xl md:text-5xl font-bold text-slate-900">互動式催眠理論瀏覽器</h1>
            <p class="mt-2 text-lg text-slate-600">深入探索與比較當代催眠的多元視角</p>
        </header>

        <div class="flex flex-col md:flex-row gap-8">
            <nav id="theory-nav" class="md:w-1/4 space-y-2">
                <div class="p-4 bg-white rounded-lg shadow-md">
                    <h3 class="text-lg font-bold mb-3 text-slate-700">理論模型</h3>
                    <div id="nav-list" class="space-y-2"></div>
                    <div class="mt-4 pt-4 border-t">
                        <label for="compare-toggle" class="flex items-center cursor-pointer">
                            <div class="relative">
                                <input type="checkbox" id="compare-toggle" class="sr-only">
                                <div class="block bg-gray-600 w-10 h-6 rounded-full"></div>
                                <div class="dot absolute left-1 top-1 bg-white w-4 h-4 rounded-full transition"></div>
                            </div>
                            <div class="ml-3 text-slate-700 font-medium">
                                比較模式
                            </div>
                        </label>
                        <p id="compare-instructions" class="text-xs text-slate-500 mt-2 hidden">請選擇兩個理論進行比較。</p>
                    </div>
                </div>
            </nav>

            <main id="content-area" class="md:w-3/4">
                <div id="content-card" class="bg-white p-6 md:p-8 rounded-lg shadow-lg content-card">
                </div>
            </main>
        </div>
    </div>

    <script>
        const theories = [
            {
                id: 0,
                title: "新解離模型",
                category: "內省",
                coreIdea: "催眠是一種解離狀態，心智中不同的部分可以分開來運作，彼此暫時失去連結。",
                details: "由希爾加德發展，此模型認為人類擁有多個認知系統。在催眠中，這些系統可以自主運作，不再受到『執行自我』的嚴格控制。個案會將一部分執行功能『移交』給催眠師，從而更容易接受暗示。",
                example: "開車時突然忘了是怎麼開過來的，這就是一種自然解離。在催眠中，個案可能感覺到自己的手臂漂浮起來，但『感覺不像自己在做決定』。",
                metaphor: "大腦的指揮官（執行自我）暫時授權給各部門（認知子系統）自主運作，並接受外部顧問（催眠師）的指導。",
                scores: { '內在體驗': 5, '社會互動': 2, '意識狀態': 5, '認知過程': 4, '生理基礎': 3 }
            },
            {
                id: 1,
                title: "神經心理生物學現象",
                category: "內省",
                coreIdea: "催眠與大腦和身體的生理機制緊密相關，是一種可觀測的神經系統現象。",
                details: "隨著大腦掃描技術的發展，研究發現催眠涉及高度聚焦的注意力狀態。Ernest Rossi認為催眠是人體自然『超晝夜節律』的一部分；Spiegel夫婦則將其定義為一種注意力調整，與大腦兩半球的協同過程有關。",
                example: "研究發現，在催眠狀態下，大腦的預設模式網絡活動會減少，而注意力網絡的連結會增強，這與高度專注的體驗一致。",
                metaphor: "如同調整樂器的頻率，催眠是學習善用身體與大腦的自然節奏，進入一種高效能的專注與療癒狀態。",
                scores: { '內在體驗': 4, '社會互動': 1, '意識狀態': 3, '認知過程': 3, '生理基礎': 5 }
            },
            {
                id: 2,
                title: "許可/被動狀態",
                category: "人際",
                coreIdea: "催眠是個案『允許』自己進入的狀態，強調個案的主動參與和合作，而非被動服從。",
                details: "傳統觀點認為個案是被動接受指令，若無反應則視為『阻抗』。現代觀點則認為，個案是積極的合作者，他們主動關注暗示，並根據自身需求調整體驗。治療師的風格（命令式 vs. 寬容式）會極大地影響個案的角色定位。",
                example: "催眠誘導語從『你將會感到放鬆』轉變為『你可以允許自己體驗一種深度放鬆』，將控制權交還給個案。",
                metaphor: "催眠師不是船長，而是領航員。他提供航線建議，但最終決定方向和速度的，是個案這艘船的船長。",
                scores: { '內在體驗': 3, '社會互動': 4, '意識狀態': 2, '認知過程': 3, '生理基礎': 1 }
            },
            {
                id: 3,
                title: "改變的意識狀態",
                category: "內省",
                coreIdea: "催眠是一種獨特的意識型態，與日常的清醒狀態有質的區別。",
                details: "此觀點認為催眠是一個特別的『場域』，在其中，個案的防衛心降低，情感更容易連結，對暗示的反應也更靈敏。儘管缺乏一致的生理指標來『證明』這種狀態，但它能很好地解釋催眠中出現的非尋常體驗。",
                example: "在催眠中體驗到時間感扭曲（感覺只過了5分鐘，實際卻是半小時），或對疼痛的感知完全消失。",
                metaphor: "如同從日常的『陸地模式』切換到探索潛意識的『潛水模式』，需要不同的裝備和心態。",
                scores: { '內在體驗': 5, '社會互動': 1, '意識狀態': 5, '認知過程': 3, '生理基礎': 2 }
            },
            {
                id: 4,
                title: "特別互動結果",
                category: "人際",
                coreIdea: "催眠並非單向施加，而是治療師與個案之間『聚焦而有意義的互動』所共同創造的結果。",
                details: "受艾瑞克森影響，此觀點強調治療關係、融洽感（Rapport）與調頻（Attunement）。治療師需要『順勢而為』，跟隨個案的內在節奏，而非強加指令。催眠的轉化力來自於這種深度的人際連結與共鳴。",
                example: "治療師觀察到個案的呼吸變慢，便順勢引導：『隨著每一次呼吸，你都可以進入更深的寧靜』，而非生硬地給予指令。",
                metaphor: "一場精心編排的雙人舞，治療師與個案互為引領者與跟隨者，共同創造出優美的舞步（療癒）。",
                scores: { '內在體驗': 3, '社會互動': 5, '意識狀態': 2, '認知過程': 4, '生理基礎': 1 }
            },
            {
                id: 5,
                title: "社會認知現象",
                category: "人際",
                coreIdea: "催眠是一種社會互動行為，個案的回應深受其信念、期望和所處情境的影響。",
                details: "此觀點認為催眠並非神秘的特殊狀態，而是日常社會行為的延伸。人們根據他們對『催眠』的預期來表現，例如，如果你相信被催眠時會忘記名字，你就很可能真的會忘記。這不是『裝』的，而是信念塑造了體驗。",
                example: "在舞台催眠秀上，觀眾的期望、群體氛圍和表演者的權威性，共同促使參與者表現出誇張的催眠反應。",
                metaphor: "一齣由催眠師擔任導演、個案擔任演員的即興戲劇。劇本由社會文化和個人信念共同寫就。",
                scores: { '內在體驗': 2, '社會互動': 5, '意識狀態': 1, '認知過程': 5, '生理基礎': 1 }
            },
            {
                id: 6,
                title: "巴伯觀點 (非狀態論)",
                category: "人際",
                coreIdea: "催眠現象是動機、合作與想像力的結果，並不需要進入一個特殊的『催眠狀態』。",
                details: "T.X. 巴伯透過研究證明，許多驚人的催眠現象（如止痛、幻覺），只要個案有足夠的動機並積極運用想像力，在沒有正式催眠引導的情況下也能達成。他強調社會責任感、催眠師特質、思考誘導和暗示能量是關鍵因素。",
                example: "一個極度專注於閱讀小說的讀者，可能會對周遭的聲音充耳不聞，甚至感受到書中角色的情緒，這就是想像力與動機的產物。",
                metaphor: "如同運動員透過高度專注和心像訓練來提升表現，催眠是引導個案運用自身內在資源（動機、想像力）達成目標的過程。",
                scores: { '內在體驗': 2, '社會互動': 4, '意識狀態': 1, '認知過程': 5, '生理基礎': 1 }
            },
            {
                id: 7,
                title: "社會角色扮演",
                category: "人際",
                coreIdea: "催眠行為是一種被社會文化所定義的『角色』，個案在無意識中扮演他們認為『被催眠者』應該有的樣子。",
                details: "由薩賓（Sarbin）等人提出，此模型認為催眠互動中，治療師和個案都在扮演相互配合的角色。個案透過『相信的想像』（believed-in imagination）將角色內化，產生真實的體驗，而不僅僅是模仿。",
                example: "著名的史丹佛監獄實驗中，扮演獄卒和囚犯的學生很快就『入戲』，產生了真實且強烈的情緒與行為改變。",
                metaphor: "方法演技派的演員，他們不是在『假裝』，而是透過完全的投入，讓自己『成為』那個角色，從而產生真實的情感和反應。",
                scores: { '內在體驗': 1, '社會互動': 5, '意識狀態': 1, '認知過程': 4, '生理基礎': 1 }
            },
            {
                id: 8,
                title: "現實檢驗觀點",
                category: "內省",
                coreIdea: "催眠暫時弱化了個案對外部現實的檢驗能力，使其更容易接受與現實不符的暗示。",
                details: "在催眠中，個案會出現所謂的『催眠邏輯』（trance logic），即可以同時相信兩件看似矛盾的事情。例如，他知道自己在辦公室，但同時也『感覺』自己真的在海灘上。這並非完全脫離現實，因為仍有『隱藏的觀察者』在監控。",
                example: "個案被暗示手中握著一顆檸檬，他不僅能『看到』檸檬，甚至可能真的分泌唾液，因為他暫時擱置了『手中其實沒有檸檬』這個現實。",
                metaphor: "觀看一部引人入勝的3D電影。你知道這一切都是特效，但你的感官和情緒卻完全投入其中，彷彿身歷其境。",
                scores: { '內在體驗': 4, '社會互動': 2, '意識狀態': 4, '認知過程': 4, '生理基礎': 2 }
            },
            {
                id: 9,
                title: "語言與體驗的條件屬性",
                category: "內省",
                coreIdea: "語言是體驗的觸發器，詞語作為一種『條件刺激』，能夠喚起與之連結的感官、情緒和認知反應。",
                details: "此觀點強調語言本身沒有意義，意義來自於個人經驗的連結。催眠師的話語透過『跨源搜索』過程，觸發個案內在的『意念動力』（Ideodynamic）反應，即想法自動轉化為感覺、情緒或行動。",
                example: "光是聽到或想到『咬一口多汁的酸檸檬』這句話，很多人就會不自覺地分泌唾液。這就是語言觸發了身體的自動反應。",
                metaphor: "語言就像是電腦的快捷鍵。每個詞語都連結到大腦資料庫中一個複雜的經驗檔案，按下快捷鍵，相關的檔案（感覺、記憶、情緒）就會被打開。",
                scores: { '內在體驗': 4, '社會互動': 3, '意識狀態': 2, '認知過程': 5, '生理基礎': 2 }
            }
        ];

        let currentState = {
            mode: 'single', // 'single' or 'compare'
            selectedId: 0,
            compareIds: []
        };

        const navList = document.getElementById('nav-list');
        const contentCard = document.getElementById('content-card');
        const compareToggle = document.getElementById('compare-toggle');
        const compareInstructions = document.getElementById('compare-instructions');
        let radarChart = null;

        function renderNav() {
            navList.innerHTML = '';
            theories.forEach(theory => {
                const button = document.createElement('button');
                button.className = 'w-full text-left p-3 rounded-md transition duration-200 nav-item hover:bg-amber-500 hover:text-white';
                button.textContent = theory.title;
                button.dataset.id = theory.id;

                if (currentState.mode === 'single' && theory.id === currentState.selectedId) {
                    button.classList.add('active');
                } else if (currentState.mode === 'compare' && currentState.compareIds.includes(theory.id)) {
                    button.classList.add('compare-active');
                }

                button.addEventListener('click', () => handleNavClick(theory.id));
                navList.appendChild(button);
            });
        }

        function handleNavClick(id) {
            if (currentState.mode === 'single') {
                currentState.selectedId = id;
            } else {
                const index = currentState.compareIds.indexOf(id);
                if (index > -1) {
                    currentState.compareIds.splice(index, 1);
                } else {
                    if (currentState.compareIds.length < 2) {
                        currentState.compareIds.push(id);
                    } else {
                        currentState.compareIds.shift();
                        currentState.compareIds.push(id);
                    }
                }
            }
            render();
        }

        function renderContent() {
            contentCard.classList.add('loading');
            setTimeout(() => {
                if (currentState.mode === 'single') {
                    renderSingleView();
                } else {
                    renderCompareView();
                }
                contentCard.classList.remove('loading');
            }, 150);
        }

        function createTheoryCardHTML(theory) {
            return `
                <div class="flex-1">
                    <h2 class="text-3xl font-bold text-amber-600 mb-2">${theory.title}</h2>
                    <p class="text-sm font-semibold text-slate-500 mb-4">分類：${theory.category}模式</p>
                    <div class="space-y-4">
                        <div>
                            <h4 class="font-bold text-slate-700">核心觀點</h4>
                            <p class="text-slate-600">${theory.coreIdea}</p>
                        </div>
                        <div>
                            <h4 class="font-bold text-slate-700">詳細說明</h4>
                            <p class="text-slate-600">${theory.details}</p>
                        </div>
                        <div>
                            <h4 class="font-bold text-slate-700">生活實例</h4>
                            <p class="text-slate-600">${theory.example}</p>
                        </div>
                        <div>
                            <h4 class="font-bold text-slate-700">形象比喻</h4>
                            <p class="text-slate-600">${theory.metaphor}</p>
                        </div>
                    </div>
                </div>
            `;
        }
        
        function renderSingleView() {
            const theory = theories.find(t => t.id === currentState.selectedId);
            contentCard.innerHTML = `
                ${createTheoryCardHTML(theory)}
                <div class="mt-8 pt-6 border-t">
                    <h3 class="text-2xl font-bold text-center mb-4 text-slate-800">理論維度分析</h3>
                    <div class="chart-container">
                        <canvas id="radarChart"></canvas>
                    </div>
                </div>
            `;
            createRadarChart([theory]);
        }

        function renderCompareView() {
            if (currentState.compareIds.length === 0) {
                contentCard.innerHTML = `<div class="text-center p-8"><h2 class="text-2xl font-bold text-slate-700">請選擇理論</h2><p class="text-slate-500 mt-2">請從左側列表中選擇一或兩個理論來進行比較。</p></div>`;
                return;
            }

            const theoriesToCompare = theories.filter(t => currentState.compareIds.includes(t.id));
            
            let cardsHTML = theoriesToCompare.map(createTheoryCardHTML).join('<div class="border-r mx-4 hidden md:block"></div>');

            contentCard.innerHTML = `
                <div class="flex flex-col md:flex-row gap-6">
                    ${cardsHTML}
                </div>
                <div class="mt-8 pt-6 border-t">
                    <h3 class="text-2xl font-bold text-center mb-4 text-slate-800">理論維度比較</h3>
                    <div class="chart-container">
                        <canvas id="radarChart"></canvas>
                    </div>
                </div>
            `;
            createRadarChart(theoriesToCompare);
        }

        function createRadarChart(chartTheories) {
            const chartCanvas = document.getElementById('radarChart');
            if (!chartCanvas) return;
            const ctx = chartCanvas.getContext('2d');
            
            if (radarChart) {
                radarChart.destroy();
            }

            const labels = ['內在體驗', '社會互動', '意識狀態', '認知過程', '生理基礎'];
            const colors = ['rgba(217, 119, 6, 0.4)', 'rgba(24, 24, 27, 0.4)'];
            const borderColors = ['rgba(217, 119, 6, 1)', 'rgba(24, 24, 27, 1)'];

            const datasets = chartTheories.map((theory, index) => ({
                label: theory.title,
                data: labels.map(label => theory.scores[label]),
                backgroundColor: colors[index % colors.length],
                borderColor: borderColors[index % borderColors.length],
                borderWidth: 2,
                pointBackgroundColor: borderColors[index % borderColors.length],
                pointRadius: 4,
            }));

            radarChart = new Chart(ctx, {
                type: 'radar',
                data: {
                    labels: labels,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        r: {
                            angleLines: {
                                color: 'rgba(0, 0, 0, 0.1)'
                            },
                            grid: {
                                color: 'rgba(0, 0, 0, 0.1)'
                            },
                            pointLabels: {
                                font: {
                                    size: 14,
                                    family: "'Noto Sans TC', sans-serif"
                                },
                                color: '#334155' // slate-700
                            },
                            ticks: {
                                beginAtZero: true,
                                max: 5,
                                stepSize: 1,
                                backdropColor: 'rgba(255, 255, 255, 0.75)'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'top',
                            labels: {
                                font: {
                                    size: 14,
                                    family: "'Noto Sans TC', sans-serif"
                                }
                            }
                        },
                        tooltip: {
                            titleFont: { family: "'Noto Sans TC', sans-serif" },
                            bodyFont: { family: "'Noto Sans TC', sans-serif" }
                        }
                    }
                }
            });
        }

        function render() {
            renderNav();
            renderContent();
        }
        
        compareToggle.addEventListener('change', (e) => {
            const isChecked = e.target.checked;
            currentState.mode = isChecked ? 'compare' : 'single';
            currentState.compareIds = [];
            
            const dot = document.querySelector('.dot');
            if(isChecked) {
                dot.style.transform = 'translateX(100%)';
                compareInstructions.classList.remove('hidden');
            } else {
                dot.style.transform = 'translateX(0)';
                compareInstructions.classList.add('hidden');
            }

            render();
        });

        document.addEventListener('DOMContentLoaded', render);

    </script>
</body>
</html>
